package minimax;

import board.*;

import java.util.*;

public final class BoardEvaluator {

    private BoardEvaluator() {
    }

    /**
     * Returns a list of tiles of a specified color currently on the board. Order the list
     * such that earlier elements are closer to/at the top (for BLACK) or left (for WHITE) goals.
     */
    public static List<Position> getTiles(Board b, int color) {
        List<Position> tiles = new ArrayList<>(10);
        if (color == Tile.BLACK) {
            for (int y = 0; y < Board.SIZE; y++) {
                for (int x = 0; x < Board.SIZE; x++) {
                    if (b.getTile(x, y) == color) {
                        tiles.add(new Position(x, y));
                    }
                }
            }
        }
        if (color == Tile.WHITE) {
            for (int x = 0; x < Board.SIZE; x++) {
                for (int y = 0; y < Board.SIZE; y++) {
                    if (b.getTile(x, y) == color) {
                        tiles.add(new Position(x, y));
                    }
                }
            }
        }
        return tiles;
    }

    /**
     * Returns a list of tiles connected to the tile at position p. Tiles blocked by opponent's
     * tile(s) are excluded from this list.
     */
    public static LinkedList<Position> getConnectedTiles(Board b, Position p) {
        int color = b.getTile(p);
        int opponent = getOpponentColor(color);
        LinkedList<Position> result = new LinkedList<>();
        Neighbors n = new Neighbors(p);
        while (!n.isEmpty()) {
            for (Position pos : n) {
                if (pos == null || p.isSameDirection(pos)) {
                    continue;
                }
                if (b.getTile(pos) == opponent) {
                    n.remove(pos.direction);
                    continue;
                }
                if (b.getTile(pos) == color) {
                    if (Board.isSameGoal(p, pos)) {
                        continue;
                    }
                    result.add(new Position(pos.x, pos.y, pos.direction));
                }
            }
            n.advance();
        }
        return result;
    }

    public static LinkedList<Position> getConnectedTiles(Board gameBoard, int x, int y) {
        return getConnectedTiles(gameBoard, new Position(x, y));
    }

    /**
     * Returns all unique chains present on the board for a particular color
     */
    public static List<List<Position>> getChains(Board b, int color) {
        List<List<Position>> results = new ArrayList<>();
        List<Position> tiles = getTiles(b, color);
        for (Position p : tiles) {
            // For each tile on the board, find a chain and add to results
            LinkedList<Position> chain = new LinkedList<>();
            chain.add(p);
            SearchNode start = new SearchNode(p, chain); // Starting node
            Stack<SearchNode> frontier = new Stack<>(); // Nodes to explore is a stack for DFS
            frontier.add(start); // Push starting node onto stack
            while (!frontier.isEmpty()) {
                SearchNode current = frontier.pop(); // Current search node we are investigating
                Position currentPos = current.p; // Current Position
                LinkedList<Position> successors = getConnectedTiles(b, currentPos); // Get all nodes validly connected to this node
                // currentPos will NEVER appear in successors, do not check currentPos in visited yet
                boolean isLeaf = true;
                LinkedList<Position> link = new LinkedList<>(current.links);
                for (Position n : successors) {
                    // Check each position in list of successors (validly connected neighbors)
                    if (link.contains(n)) {
                        // Do not re-explore positions
                        continue;
                    }
                    isLeaf = false;
                    Position nextPos = new Position(n);
                    link = new LinkedList<>(current.links);
                    link.add(nextPos);
                    frontier.add(new SearchNode(nextPos, link));
                }
                if (isLeaf && !hasMultipleTilesInGoal(link)) {
                    results.add(link);
                }
            }
        }
        return results;
    }

    public static List<List<Position>> getChainsDFS(Board b, int color) {
        List<List<Position>> results = new LinkedList<>();
        List<Position> tiles = getTiles(b, color);
        for (Position p : tiles) {
            results.addAll(getChainDFS(b, p));
        }
        return results;
    }

    /**
     * Builds a chain (series of connected positions), starting at the specified position, where each element is a
     * Position that corresponds to a location on the Board b containing a Tile of the specified color.
     */
    public static List<List<Position>> getChainDFS(Board b, Position start) {
        List<List<Position>> chains = new LinkedList<>();
        List<Position> chain = new LinkedList<>();
        chain.add(start);
        SearchNode first = new SearchNode(start, chain);
        Stack<SearchNode> frontier = new Stack<>();
        frontier.push(first);
        while (!frontier.isEmpty()) {
            SearchNode current = frontier.pop();
            Position currentPos = current.p;
            List<Position> successors = getConnectedTiles(b, currentPos);
            boolean isLeaf = true;
            List<Position> currentLinks = new LinkedList<>(current.links);
            for (Position p : successors) {
                if (currentLinks.contains(p)) {
                    continue;
                }
                isLeaf = false;
                Position next = new Position(p);
                currentLinks = new LinkedList<>(current.links);
                currentLinks.add(next);
                frontier.add(new SearchNode(next, currentLinks));
            }
            if (isLeaf && !hasMultipleTilesInGoal(currentLinks)) {
                chains.add(currentLinks);
            }
        }
        return chains;
    }

    /**
     * Examines each chain present on the board for some color and removes insignificant chains.
     * An insignificant chain is one where
     */
    private static void processChains(List<LinkedList<Position>> chains) {

    }

    /**
     * Parses through the chains and returns true if a valid network exists in the chain.
     */
    public static boolean hasNetwork(List<List<Position>> chains) {
        for (List<Position> chain : chains) {
            if (chain.size() < 6) {
                continue;
            }
            Position goal1 = chain.get(0);
            Position goal2 = chain.get(chain.size() - 1);
            if (Board.isBothGoals(goal1, goal2) && !hasMultipleTilesInGoal(chain)) {
                // Starts and ends in appropriate goal positions
                return true;
            }
        }
        return false;
    }

    /**
     * Returns 0 if BLACK won, 1 if WHITE won, or -1 if there is no winner.
     */
    public static int hasWon(Board b) {

        return -1;
    }

    /**
     * Examines a chain of positions and returns true if the chains consists
     * of more than one tile in the same goal section. Such a chain is considered
     * invalid and should not be further considered.
     */
    private static boolean hasMultipleTilesInGoal(List<Position> chain) {
        boolean goalOne = false; // left or top
        boolean goalTwo = false; // right or bottom
        for (Position p : chain) {
            if (p.x == 0 || p.y == 0) {
                if (goalOne) {
                    return true;
                }
                goalOne = true;
            }
            if (p.x == Board.SIZE - 1 || p.y == Board.SIZE - 1) {
                if (goalTwo) {
                    return true;
                }
                goalTwo = true;
            }
        }
        return false;
    }

    /**
     * Returns the integer corresponding to the specified color's opponent. White's opponent is
     * Black, and Black's opponent is White.
     */
    private static int getOpponentColor(int color) {
        if (color == Tile.BLACK) {
            return Tile.WHITE;
        }
        return Tile.BLACK;
    }

    /**
     * Helper method to print each position in a chain of linked tiles.
     */
    public static void printChain(List<Position> chain) {
        String s = "";
        for (Position p : chain) {
            s = s + p + " ";
        }
        System.out.println(s);
    }

    /**
     * Helper method to print each chain present on the board.
     */
    public static void printChains(List<List<Position>> chains) {
        for (List<Position> chain : chains) {
            printChain(chain);
        }
    }

    static class SearchNode {

        Position p;
        List<Position> links;

        public SearchNode(Position p) {
            this(p, new LinkedList<>());
        }

        public SearchNode(Position p, List<Position> links) {
            this.p = p;
            this.links = links;
        }

    }

    public static void main(String[] args) {
        Board b = new Board();
        b.setTile(2, 0, Tile.BLACK);
        b.setTile(2, 2, Tile.BLACK);
        b.setTile(2, 5, Tile.BLACK);
        b.setTile(3, 5, Tile.BLACK);
        b.setTile(1, 3, Tile.BLACK);
        b.setTile(3, 3, Tile.BLACK);
        b.setTile(5, 5, Tile.BLACK);
        b.setTile(5, 7, Tile.BLACK);
        b.setTile(6, 0, Tile.BLACK);
        b.setTile(6, 5, Tile.BLACK);
        List<List<Position>> chains = BoardEvaluator.getChainsDFS(b, Tile.BLACK);
        printChains(chains);
    }

}
