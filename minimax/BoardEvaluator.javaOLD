package minimax;


import board.Board;
import board.Neighbors;
import board.Position;
import board.Tile;
import player.Move;

import java.util.*;

public final class BoardEvaluator {

    public static final int MAX = 10000000;
    public static final int MIN = -10000000;

    private static int value; // Keep track of value as we process our board
    static List<Position> whiteTiles; // List of WHITE tiles on the board
    static List<LinkedList<Position>> whiteChains; // List of WHITE chains
    static List<LinkedList<Position>> longestWhiteChains;
    static int numWhitePairs; // count of unique pairs of white tiles
    static List<Position> blackTiles; // List of BLACK tiles on the board
    static List<LinkedList<Position>> blackChains; // List of BLACK chains
    static List<LinkedList<Position>> longestBlackChains;
    static int numBlackPairs; // count of unique pairs of black tiles
    // Track number of tiles in each goal zone
    static int topGoal = 0;
    static int botGoal = 0;
    static int leftGoal = 0;
    static int rightGoal = 0;


    /**
     * Private constructor. This class is not meant to be instantiated.
     */
    private BoardEvaluator() {
    }

    public static void clearMetrics() {
        value = 0;
        whiteTiles = null;
        whiteChains = null;
        longestWhiteChains = null;
        numWhitePairs = 0;
        blackTiles = null;
        blackChains = null;
        longestBlackChains = null;
        numBlackPairs = 0;
        topGoal = 0;
        botGoal = 0;
        leftGoal = 0;
        rightGoal = 0;
    }

    /**
     * Scans the board and adds Positions where a Tile is to the appropriate
     * tile list. Also counts the number of tiles in each goal zone.
     */
    private static void buildTilesList(Board b) {
        whiteTiles = new ArrayList<>(10);
        blackTiles = new ArrayList<>(10);
        for (int x = 0; x < Board.SIZE; x++) {
            for (int y = 0; y < Board.SIZE; y++) {
                if (b.getTile(x, y) == Tile.WHITE) {
                    // Traverse top to bottom, left to right
                    whiteTiles.add(new Position(x, y));
                    if (x == 0) {
                        leftGoal++;
                        if (leftGoal == 1 && (y == 3 || y == 4)) {
                            value = 1;
                        }
                    }
                    if (x == 7) {
                        rightGoal++;
                        if (rightGoal == 1 && (y == 3 || y == 4)) {
                            value = 1;
                        }
                    }
                }
                if (b.getTile(y, x) == Tile.BLACK) {
                    // Traverse left to right, top to bottom
                    blackTiles.add(new Position(y, x));
                    if (x == 0) {
                        topGoal++;
                        if (topGoal == 1 && (y == 3 || y == 4)) {
                            value = 1;
                        }
                    }
                    if (x == 7) {
                        botGoal++;
                        if (botGoal == 1 && (y == 3 || y == 4)) {
                            value = 1;
                        }
                    }
                }
            }
        }
    }

    /**
     * Gets all valid chains starting from each of the tiles present on the board.
     */
    private static List<LinkedList<Position>> getChains(Board b, List<Position> tiles) {
        List<LinkedList<Position>> chains = new LinkedList<>();
        for (Position p : tiles) {
            chains.addAll(getChains(b, p));
        }
        return chains;
    }

    /**
     * Performs a DFS to find chains that originate from Position p. A chain is
     * one that extends all the way to a leaf. This method will also count
     * the number of unique pairs that exist for a color: A->B and B->A
     * counts as 1 unique pair.
     * (2,2)->(3,3)->(5,5) is a chain
     * (2,2)->(3,3) on the same board is NOT a chain, since there is a position
     * yet to be explored (5,5)
     */
    private static List<LinkedList<Position>> getChains(Board b, Position p) {
        List<LinkedList<Position>> chains = new ArrayList<>(); // To be returned
        // Set up our starting search node
        SearchNode start = new SearchNode(p);
        // DFS: explore deep, then wide --> Stack
        Stack<SearchNode> frontier = new Stack<>();
        frontier.push(start);
        while (!frontier.isEmpty()) {
            SearchNode current = frontier.pop(); // Next node/position to explore
            Position currentPos = current.p;
            LinkedList<Position> currentLink = new LinkedList<>(current.links);
            currentLink.add(currentPos);
            if (tilesInSameGoal(currentLink)) {
                // Invalid chain: cannot have more than one tile in the same
                // goal in a chain of tiles.
                continue;
            }
            if (terminateChain(currentLink)) {
                // Terminate a chain if it reaches an goal
                chains.add(currentLink);
            }
            else {
                List<Position> successors = getSuccessors(b, currentPos);
                boolean isLeaf = true;
                for (Position next : successors) {
                    if (!currentLink.contains(next)) {
                        // Do not include tiles twice
                        isLeaf = false;
                        frontier.add(new SearchNode(new Position(next), currentLink));
                    }
                }
                if (isLeaf) {
                    chains.add(currentLink);
                }
            }
        }
        // For each starting position, sort by length of the chain
        chains.sort(new Comparator<LinkedList<Position>>() {
            @Override
            public int compare(LinkedList<Position> o1, LinkedList<Position> o2) {
                return Integer.valueOf(o1.size()).compareTo(o2.size()) * -1;
            }
        });
        return chains;
    }

    /**
     * Returns only the longest, unique, chains. A unique chain is one with at
     * least one new position not present in other longest chains. Longest
     * chain will be null if and only if there was a network detected!
     */
    private static List<LinkedList<Position>> getLongestChains(List<LinkedList<Position>> chains) {
        Set<Position> visited = new HashSet<>();
        List<LinkedList<Position>> result = new ArrayList<>();
        for (LinkedList<Position> chain : chains) {
            if (hasNetwork(chain)) {
                return null; // SPECIAL CASE FOR NETWORKS
            }
            if (!visited.containsAll(chain)) {
                visited.addAll(chain);
                result.add(chain);
            }
        }
        return result;
    }

    /**
     * Returns true if the chain should be terminated early. Early termination
     * means to stop the chain even though there are other connected nodes to
     * consider.
     */
    private static boolean terminateChain(LinkedList<Position> chain) {
        if (chain.size() > 1) {
            // For chains larger than 1
            Position last = chain.getLast();
            if (Board.isGoal(last)) {
                // Terminate if we added a goal node
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if the chain starts and ends in the same goal
     */
    private static boolean tilesInSameGoal(LinkedList<Position> chain) {
        if (chain.size() > 1) {
            Position first = chain.getFirst();
            Position last = chain.getLast();
            return Board.isSameGoal(first, last);
        }
        return false;
    }

    /**
     * Returns a list of tiles validly connected to the tile on Board b
     * at Position p.
     * Two tiles in the same goal zone are not considered connected.
     * This method also counts the number of pairs
     */
    private static List<Position> getSuccessors(Board b, Position p) {
        List<Position> successors = new ArrayList<>();
        int color = b.getTile(p); // Color of tile at this position
        int other = Board.getOtherColor(color); // Opponent's color
        Neighbors neighbors = new Neighbors(p);
        while (!neighbors.isEmpty()) {
            for (Position n : neighbors) {
                if (n == null || p.isSameDirection(n)) {
                    // If n is not a valid neighbor: off board or exists on the
                    // same line we have been traveling on
                    continue;
                }
                if (b.getTile(n) == other) {
                    // If n references the opponent's color, this line is now
                    // blocked
                    neighbors.remove(n.direction); // Remove this line/direction
                    continue;
                }
                if (b.getTile(n) == color) {
                    // Found a tile that is our own
                    if (Board.isSameGoal(p, n)) {
                        // Do not add if it is in the same goal region
                        continue;
                    }
                    successors.add(new Position(n));
                }
            }
            neighbors.advance(); // Check one more ring out
        }
        return successors;
    }

    /**
     * Returns true if the chain is a valid network.
     */
    private static boolean hasNetwork(LinkedList<Position> chain) {
        if (chain.size() > 5) {
            Position first = chain.getFirst();
            Position last = chain.getLast();
            return Board.isBothGoals(first, last);
        }
        return false;
    }

    /**
     * Returns a list of valid moves for the current player.
     */
    public static List<Move> getValidMoves(Board b) {
        int turn = b.getTurn();
        int numTiles = b.getCurrentPlayerTileCount();
        List<Move> moves = new ArrayList<>(64);
        if (numTiles < 10) {
            // ADD moves
            for (int x = 0; x < Board.SIZE; x++) {
                for (int y = 0; y < Board.SIZE; y++) {
                    if (b.isValidTilePlacement(x, y, turn)) {
                        moves.add(new Move(x, y));
                    }
                }
            }
        }
        else {
            // STEP moves
            for (int x = 0; x < Board.SIZE; x++) {
                for (int y = 0; y < Board.SIZE; y++) {
                    if (b.getTile(x, y) == turn) {
                        // We can "remove" this tile
                        Board temp = new Board(b);
                        temp.setTile(x, y, Tile.EMPTY);
                        for (int x2 = 0; x2 < Board.SIZE; x2++) {
                            for (int y2 = 0; y2 < Board.SIZE; y2++) {
                                if ((x2 != x || y2 != y) && temp.isValidTilePlacement(x2, y2, turn)) {
                                    moves.add(new Move(x2, y2, x, y));
                                }
                            }
                        }
                    }
                }
            }
        }
        return moves;
    }

    /**
     * Parses the Board b to extract useful features to help evaluate the board.
     */
    private static void getFeatures(Board b) {
        clearMetrics();
        buildTilesList(b);
        whiteChains = getChains(b, whiteTiles);
        blackChains = getChains(b, blackTiles);
        numWhitePairs = countPairs(b, whiteTiles);
        numBlackPairs = countPairs(b, blackTiles);
        longestWhiteChains = getLongestChains(whiteChains);
        longestBlackChains = getLongestChains(blackChains);
    }

    /**
     * Returns a value to indicate how good this board is.
     * Note: when we issue a move via Player.executeMove(move),
     * the resulting board.turn will change. Therefore, we must
     * evaluate the Board b from the "other" player's perspective.
     * The "other" player is the player who's turn it currently is NOT.
     */
    public static int evaluate(Board b) {
        // The player who made a move to get to this Board state
        int player = b.getOpponent();
        getFeatures(b);
        if (b.getCurrentPlayerTileCount() > 5 && hasWon(b.getTurn())) {
            // Player made a step move that resulted in opponent's victory
            return MIN;
        }
        if (b.getOtherPlayerTileCount() > 5 && hasWon(player)) {
            // Player made a move that resulted in their own victory
            return MAX;
        }
        int pair = processPairs(player);
        value = value + pair;
        int longestChain = processLongestChain(player);
        value = value + longestChain;
        value = value + processGoalCount(player) + processGoalCount(b.getTurn());
        return value;
    }

    public static boolean gameOver() {
        return hasWon(Tile.WHITE) || hasWon(Tile.BLACK);
    }

    /**
     * Checks if a particular color has won. Call after getFeatures().
     */
    public static boolean hasWon(int color) {
        if (color == Tile.BLACK) {
            return longestBlackChains == null;
        }
        if (color == Tile.WHITE) {
            return longestWhiteChains == null;
        }
        return false;
    }

    /**
     * Counts the number of unique pairs for a given list of tiles on the board.
     */
    private static int countPairs(Board b, List<Position> tiles) {
        int pairs = 0;
        for (Position p : tiles) {
            pairs = pairs + getSuccessors(b, p).size();
        }
        return pairs / 2;
    }

    /**
     * The specified color is the player who just made a move.
     * Intended to be called after getFeatures().
     */
    private static int processPairs(int color) {
        if (color == Tile.BLACK) {
            return numBlackPairs - numWhitePairs;
        }
        else return numWhitePairs - numBlackPairs;
    }

    /**
     * Since there may be multiple longest chains, we allow it since
     * multiple longest chains give way for more possibilities.
     */
    private static int processLongestChain(int color) {
        int black = 0;
        int white = 0;
        for (LinkedList<Position> chain : longestBlackChains) {
            if (chain.size() > black) {
                black = chain.size();
            }
        }
        for (LinkedList<Position> chain : longestWhiteChains) {
            if (chain.size() > white) {
                white = chain.size();
            }
        }
        black = black * black;
        white = white * white;
        if (color == Tile.BLACK) {
            return black - white;
        }
        else return white - black;
    }

    /**
     * Penalize the score for having more than one tile in a goal area.
     */
    private static int processGoalCount(int color) {
        int val = 0;
        if (color == Tile.BLACK) {
            if (blackTiles.size() < 3 && topGoal == 1 || botGoal == 1) {
                val = 2;
            }
            if (topGoal > 1) {
                val = val - topGoal;
            }
            if (botGoal > 1) {
                val = val - botGoal;
            }
            if (topGoal == 1) {
                val = val + 1;
            }
            if (botGoal == 1) {
                val = val + 1;
            }
            return val;
        }
        else {
            if (whiteTiles.size() < 3 && leftGoal == 1 || rightGoal == 1) {
                val = 2;
            }
            if (leftGoal > 1) {
                val = val - leftGoal;
            }
            if (rightGoal > 1) {
                val = val - rightGoal;
            }
            if (leftGoal == 1) {
                val = val + 1;
            }
            if (rightGoal == 1) {
                val = val + 1;
            }
            return val;
        }
    }


    /**
     * Helper method to print each position in a chain of linked tiles.
     */
    public static void printChain(List<Position> chain) {
        String s = "";
        for (Position p : chain) {
            s = s + p + " ";
        }
        System.out.println(s);
    }

    /**
     * Helper method to print each chain present on the board.
     */
    public static void printChains(List<LinkedList<Position>> chains) {
        for (LinkedList<Position> chain : chains) {
            printChain(chain);
        }
    }

    /**
     * Helper method to print the board's features.
     */
    public static void printMetrics() {
        System.out.println("White Tiles =======================");
        printChain(whiteTiles);
        System.out.println("Black Tiles =======================");
        printChain(blackTiles);
        System.out.println("White Chains ======================");
        printChains(whiteChains);
        System.out.println("Black Chains ======================");
        printChains(blackChains);
        System.out.println("Longest White Chains ==============");
        printChains(longestWhiteChains);
        System.out.println("Longest Black Chains ==============");
        printChains(longestBlackChains);
        System.out.println("Number of white pairs: " + numWhitePairs);
        System.out.println("Number of black pairs: " + numBlackPairs);
        System.out.println("Left goal count: " + leftGoal);
        System.out.println("Right goal count: " + rightGoal);
        System.out.println("Top goal count: " + topGoal);
        System.out.println("Bottom goal count: " + botGoal);


    }

    public static void main(String[] args) {
        Board b = new Board();
        b.setTile(0, 5, Tile.WHITE);
        b.incrementWhite();
        b.endTurn();
        System.out.println(evaluate(b));
    }

    private static class SearchNode {

        private Position p;
        private LinkedList<Position> links;

        public SearchNode(Position p) {
            this(p, new LinkedList<>());
        }

        public SearchNode(Position p, LinkedList<Position> links) {
            this.p = p;
            this.links = links;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            for (Position p : links) {
                sb.append(p);
                sb.append(" ");
            }
            return sb.toString();
        }

    }

}
